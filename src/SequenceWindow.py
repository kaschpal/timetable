import gi
gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, Gdk
import datetime
from . import config
from .config import dbglog


class ClassNotebook(Gtk.Notebook):
    """ This is one of the tree views, which are displayed by the mainwindow.
    The notebook has a tab for each class. The tabs are generated by calling update()
    from the .timetable.
    """
    def __init__(self, parent):
        Gtk.Notebook.__init__(self)
        self.parent = parent

        # here come all current tabs
        self.__tabs = []
        self.connect("map", self.showHandler)
        self.set_scrollable( True )
        self.__savelist = []
        self.currentPage = None

    def showHandler(self, wid):
        """When the notebook becomes visible, update all tabs."""
        self.update()

    def update(self):
        """Refreshes the tabs and updates the sequences."""
        # first, remove all
        for tab in self.__tabs:
            self.detach_tab(tab)

        # now add from the time table
        for name in self.parent.environment.timeTab.getClassList():
            #page = Gtk.Box()
            #page.add(SequenceWindow())
            page = SequenceTV(name, parent=self)
            self.append_page(page, Gtk.Label( name ))
            self.__tabs.append(page)
            page.update()

        self.show_all()


class SequenceTV(Gtk.ScrolledWindow):
    """A Textview consisiting of the

        number of lesson
        date of lesson
        period of lesson and
        topic of the lesson.

    The content is read from the timetable and written into the timetable, when a
    tab is switched or the view (parent) becomes invisible.
    """

    def __init__(self, name, parent):
        Gtk.ScrolledWindow.__init__(self )
        self.parent = parent

        self.name = name    # classname

        # a scrollbar for the child widget (that is going to be the textview)
        #scrolled_window = Gtk.ScrolledWindow()
        self.set_border_width(5)
        self.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.nrBuf = Gtk.TextBuffer()
        self.dateBuf = Gtk.TextBuffer()
        self.periodBuf = Gtk.TextBuffer()
        self.sequenceBuf = Gtk.TextBuffer()

        nrLab = Gtk.Label()
        dateLab = Gtk.Label()
        periodLab = Gtk.Label()
        sequenceLab = Gtk.Label()

        vsep1 = Gtk.VSeparator()
        vsep2 = Gtk.VSeparator()
        vsep3 = Gtk.VSeparator()

        nrLab.set_text(_("#"))
        dateLab.set_text(_("date"))
        periodLab.set_text(_("h"))
        sequenceLab.set_text(_("topic"))
        nrLab.set_width_chars(3)
        periodLab.set_width_chars(3)
        dateLab.set_width_chars(15)

        # a textview (displays the buffer)
        nrTextView = Gtk.TextView(buffer=self.nrBuf)
        dateTextView = Gtk.TextView(buffer=self.dateBuf)
        periodTextView = Gtk.TextView(buffer=self.periodBuf )
        self.sequenceTextView = Gtk.TextView(buffer=self.sequenceBuf)

        # wrap the text, if needed, breaking lines in between words
        nrTextView.set_wrap_mode(Gtk.WrapMode.WORD)
        dateTextView.set_wrap_mode(Gtk.WrapMode.WORD)
        periodTextView.set_wrap_mode(Gtk.WrapMode.WORD)
        self.sequenceTextView.set_wrap_mode(Gtk.WrapMode.WORD)

        #set justifications
        nrTextView.set_justification(Gtk.Justification.CENTER)
        dateTextView.set_justification(Gtk.Justification.RIGHT)
        periodTextView.set_justification(Gtk.Justification.CENTER)

        #set date/period are not to edit
        nrTextView.set_editable(False)
        dateTextView.set_editable(False)
        periodTextView.set_editable(False)

        # the topic should fill the rest of the empty space
        # and the textview should be expanded in the beginning
        sequenceLab.set_hexpand(True)
        self.sequenceTextView.set_vexpand(True)

        # x, then y
        grid = Gtk.Grid()
        grid.attach(nrLab, 0, 0, 1, 1)
        grid.attach(vsep1,  1, 0, 1, 2)
        grid.attach(dateLab, 2, 0, 1, 1)
        grid.attach(vsep2,  3, 0, 1, 2)
        grid.attach(periodLab, 4, 0, 1, 1)
        grid.attach(vsep3,  5, 0, 1, 2)
        grid.attach(sequenceLab, 6, 0, 1, 1)

        grid.attach(nrTextView, 0, 1, 1, 1)
        grid.attach(dateTextView, 2, 1, 1, 1)
        grid.attach(periodTextView, 4, 1, 1, 1)
        grid.attach(self.sequenceTextView, 6, 1, 1, 1)
        self.add(grid)

        # when the widget is visible, load the sequence and save it, when it becomes
        # invisible
        self.connect("map", self.__loadSequence  )
        self.connect("unmap", self.__saveSequence  )
        self.sequenceList = []


    def __loadSequence(self, wid):
        """Reloads the sequence from the timetalbe, when the tab becomes
        visibile. This is called from a signal.
        """
        self.sequenceList = self.parent.parent.environment.timeTab.getSequence(self.name)
        self.parent.currentPage = self
        self.update()


    def __saveSequence(self, wid):
        """Saves the sequence to the timetalbe, when the tab becomes
        invisibile. This is called from a signal.
        Updates values in the parent too.
        """
        start = self.sequenceBuf.get_start_iter()
        end = self.sequenceBuf.get_end_iter()
        self.sequenceList = self.sequenceBuf.get_text(start, end, False).split("\n")
        self.parent.parent.environment.timeTab.putSequence(self.name, self.sequenceList)
        dbglog("save")


    def save(self):
        """Public alias of __saveSequence()"""
        self.__saveSequence(self)


    def update(self):
        """Actual update method: reads the sequence from the timetable and
        formats it into the textview-columns.
        """
        name = self.name
        dates_of_class = self.parent.parent.environment.timeTab.getDatesOfClass(name)

        # set the date-column
        dates = [d for d, p in dates_of_class]
        dates = [config.weekdaysShort[d.isoweekday()] + "  " +
            "{0:02d}".format(d.day) + "." + "{0:02d}".format(d.month) + "." + str(d.year) for d in dates]
        datestxt = "\n".join(dates)
        self.dateBuf.set_text(datestxt)

        # set the period-column
        periods = [p for d, p in dates_of_class]
        periods = [str(p) for p in periods]
        txt = "\n".join(periods)
        self.periodBuf.set_text(txt)

        # set the nr-column
        ns = range(1, len(dates_of_class) + 1)
        ns = [str(n) for n in ns]
        txt = "\n".join(ns)
        self.nrBuf.set_text(txt)

        # set the sequence
        sl = self.sequenceList
        sl = [str(t) for t in sl]
        txt = "\n".join(sl)
        self.sequenceBuf.set_text(txt)

        # set focus to the sequence
        #self.sequenceTextView.place_cursor_onscreen()


        #dbglog("update seq " + name)


